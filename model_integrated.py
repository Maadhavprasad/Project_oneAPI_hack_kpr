# -*- coding: utf-8 -*-
"""intel_hackday.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11iFhFtKmWC07QSt2KPgcMIHG8jBEWqJk
"""

!pip install transformers==4.37.0 autoawq==0.2.3 torch==2.2.0

from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline, TextStreamer
import torch

DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

# Initialize Hugging Face model and tokenizer
model_name_or_path = "TheBloke/Mistral-7B-Instruct-v0.2-AWQ"
tokenizer = AutoTokenizer.from_pretrained(model_name_or_path)
model = AutoModelForCausalLM.from_pretrained(model_name_or_path, low_cpu_mem_usage=True, device_map="auto")

# Generation parameters
generation_params = {
    "do_sample": True,
    "temperature": 0.7,
    "top_p": 0.95,
    "top_k": 40,
    "max_new_tokens": 4096,
    "repetition_penalty": 1.1
}

# Inference via Transformers' pipeline
pipe = pipeline("text-generation", model=model, tokenizer=tokenizer, **generation_params, return_full_text=False)

# Using the text streamer to stream output one token at a time
streamer = TextStreamer(tokenizer, skip_prompt=True, skip_special_tokens=True)

#mark 1



def predict_best_time(routine_dict, wakeup_time, bedtime, goals):
    # Prepare the routine string based on the routine dictionary
    routine_str = "\n".join([f"{task}: {time}" for task, time in routine_dict.items()])

    # Create the prompt
    goals_str = ", ".join(goals)
    prompt = (f"My current routine is as follows:\n{routine_str}\n"
              f"My wakeup time is {wakeup_time} and my bedtime is {bedtime}.\n"
              f"My goals are to {goals_str}.\n"
              f"suggeste time that suits for the goal."
              f"Based on this information, please suggest a new daily routine, including specific time slots "
              f"for tasks related to my goals. Format the routine as 'Task: Time Slot'."
              f"Ensure that learning tasks,cooking which are time consuming , are scheduled for at least 1 hour to allow for deep focus and effectiveness.")
    # Generate response using the Mistral model
    response = pipe(prompt, max_length=250)  # You can adjust max_length if necessary
    generated_text = response[0]["generated_text"].strip()

    return generated_text

#concert normal dict to dict that accepts freetime function


def convert_routine_dict(routine_dict):
    _to_routine_dict = {}
    for activity, time_range in routine_dict.items():
        # Split the time range by ' to ' and strip any extra spaces
        times = [time.strip() for time in time_range.split(' to ')]
        _to_routine_dict[activity] = times
    return _to_routine_dict

#free time finder function


from datetime import datetime

# Helper function to convert 'HH:MM' to decimal hours
def time_to_decimal(time_str):
    t = datetime.strptime(time_str, '%H:%M')
    return t.hour + t.minute / 60

# Helper function to convert decimal hours back to 'HH:MM' format
def decimal_to_time(decimal_time):
    hours = int(decimal_time)
    minutes = int((decimal_time - hours) * 60)
    return f'{hours:02}:{minutes:02}'

# Function to convert routine_dict from '6:00 to 7:00' format to ['06:00', '07:00'] format
def convert_routine_format(routine_dict):
    converted_dict = {}
    for activity, time_range in routine_dict.items():
        start_time, end_time = [time.strip() for time in time_range.split(' to ')]
        # Ensure the times are in 'HH:MM' format
        start_time = datetime.strptime(start_time, '%H:%M').strftime('%H:%M')
        end_time = datetime.strptime(end_time, '%H:%M').strftime('%H:%M')
        converted_dict[activity] = [start_time, end_time]
    return converted_dict

def find_free_time(routine_dict, wake_up_time, bed_time):
    # Convert wake-up and bed time to decimal hours
    wake_up_time = time_to_decimal(wake_up_time)
    bed_time = time_to_decimal(bed_time)

    # Prepare a list of time slots from the routine dictionary
    time_slots = []

    for activity, times in routine_dict.items():
        start_time = time_to_decimal(times[0])  # Convert to decimal hours
        end_time = time_to_decimal(times[1])    # Convert to decimal hours
        time_slots.append((start_time, end_time))

    # Sort the time slots by starting time
    time_slots.sort()

    # Initialize free time slots list
    free_time_slots = []

    # Find gaps between time slots
    if time_slots:
        # Check gap between wake-up time and the first activity
        if wake_up_time < time_slots[0][0]:
            free_time_slots.append((wake_up_time, time_slots[0][0]))

        # Check gaps between activities
        for i in range(len(time_slots) - 1):
            if time_slots[i][1] < time_slots[i + 1][0]:  # Ensure there is a gap
                free_time_slots.append((time_slots[i][1], time_slots[i + 1][0]))

        # Check gap between the last activity and bed time
        if time_slots[-1][1] < bed_time:
            free_time_slots.append((time_slots[-1][1], bed_time))

    # Convert the free time slots to 'HH:MM' format
    formatted_free_time_slots = [(decimal_to_time(start), decimal_to_time(end)) for start, end in free_time_slots]

    return formatted_free_time_slots

import re
from datetime import datetime, timedelta

# Convert time string to datetime object
def time_to_datetime(time_str):
    return datetime.strptime(time_str, "%H:%M")

# Convert datetime object to time string
def datetime_to_time_str(dt):
    return dt.strftime("%H:%M")

# Check if a time slot is free based on routine dictionary
def is_free_time(slot, routine_dict):
    slot_start, slot_end = time_to_datetime(slot[0]), time_to_datetime(slot[1])
    for times in routine_dict.values():
        task_start, task_end = time_to_datetime(times[0]), time_to_datetime(times[1])
        if not (slot_end <= task_start or slot_start >= task_end):
            return False
    return True

# Parse the description to extract tasks and time slots
def parse_routine_description(description):
    task_suggestions = {}

    # Match each line in the description
    pattern = r"(\d+)\.\s*(.+?):\s*(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})"
    matches = re.findall(pattern, description)

    for match in matches:
        task_number, task_name, start_time, end_time = match
        task_suggestions[task_name.strip().lower()] = [start_time.strip(), end_time.strip()]

    return task_suggestions

# Function to adjust time for certain tasks
def adjust_task_time(task_time):
    start_time = time_to_datetime(task_time[0])
    end_time = time_to_datetime(task_time[1])
    duration = (end_time - start_time).total_seconds() / 60  # duration in minutes

    # Example of reducing time for specific tasks
    time_wasting_tasks = ['mobileuse', 'leisure/relaxation']  # add other time-wasting tasks here

    if task_time[0].strip().lower() in time_wasting_tasks:
        # Reduce duration by 50% for time-wasting tasks
        new_duration = duration * 0.5
        new_end_time = start_time + timedelta(minutes=new_duration)
        return [task_time[0], datetime_to_time_str(new_end_time)]

    return task_time  # return original if no adjustment needed

# Allocate tasks into the routine dictionary
def allocate_tasks(task_suggestions, routine_dict):
    for task, time_slot in task_suggestions.items():
        time_slot = adjust_task_time(time_slot)  # Adjust time for the task

        if is_free_time(time_slot, routine_dict):
            routine_dict[task] = time_slot
            print(f"Added task: {task} with time slot: {time_slot}")
    return routine_dict

# Main function to update routine based on description and initial routine
def update_routine(description, initial_routine):
    # Parse the description and extract task suggestions
    task_suggestions = parse_routine_description(description)

    # Update routine dictionary with allocated tasks
    updated_routine = allocate_tasks(task_suggestions, initial_routine.copy())

    return updated_routine

import re
from datetime import datetime, timedelta

# Convert time string to datetime object
def time_to_datetime(time_str):
    return datetime.strptime(time_str, "%H:%M")

# Convert datetime object to time string
def datetime_to_time_str(dt):
    return dt.strftime("%H:%M")

# Calculate duration between two times
def duration(start, end):
    start_time = time_to_datetime(start)
    end_time = time_to_datetime(end)
    return (end_time - start_time).total_seconds() / 60  # returns duration in minutes

# Check if a time slot is free based on routine dictionary
def is_free_time(slot, routine_dict):
    slot_start, slot_end = time_to_datetime(slot[0]), time_to_datetime(slot[1])
    for times in routine_dict.values():
        task_start, task_end = time_to_datetime(times[0]), time_to_datetime(times[1])
        if not (slot_end <= task_start or slot_start >= task_end):
            return False
    return True

# Parse noisy description to extract goals, preferred times, and task suggestions
def parse_description(description):
    goal_times = {}
    task_suggestions = {}

    for line in description.split('.'):
        # Extract goal and preferred time
        goal_match = re.search(r"goal\s*(\w+)", line, re.IGNORECASE)
        time_match = re.search(r"(\d{1,2}:\d{2})\s*(?:to|until|-)\s*(\d{1,2}:\d{2})", line, re.IGNORECASE)

        # Extract task suggestions
        task_match = re.search(r"Task:\s*(.+?)\s*Time Slot:\s*(\d{1,2}:\d{2}\s*-\s*\d{1,2}:\d{2})", line, re.IGNORECASE)

        if goal_match and time_match:
            goal = goal_match.group(1).strip().lower()
            start_time, end_time = time_match.groups()
            goal_times[goal] = [start_time, end_time]

        if task_match:
            task_name = task_match.group(1).strip().lower()
            time_slot = task_match.group(2).strip().split(' - ')
            task_suggestions[task_name] = time_slot

    return goal_times, task_suggestions

# Allocate goals and incorporate task suggestions into the routine dictionary
def allocate_goals(goals, goal_times, task_suggestions, free_time, routine_dict):
    # Update routine with suggested tasks first
    for task, time_slot in task_suggestions.items():
        if is_free_time(time_slot, routine_dict):
            routine_dict[task] = time_slot
            continue

    for goal in goals:
        goal = goal.lower()
        # Check if goal has a preferred time
        if goal in goal_times:
            preferred_start, preferred_end = goal_times[goal]
            if is_free_time((preferred_start, preferred_end), routine_dict):
                routine_dict[goal] = [preferred_start, preferred_end]
                continue

        # If no preferred time or preferred time not available, allocate in free slots
        for slot in free_time:
            if is_free_time(slot, routine_dict):
                routine_dict[goal] = list(slot)
                break

    return routine_dict

# Main function to update routine based on description, goals, and initial routine
def update_routine(description, goals, initial_routine, free_time):
    # Clean noisy description and extract goal preferences and task suggestions
    goal_times, task_suggestions = parse_description(description)

    # Update routine dictionary with goals allocated in free time
    updated_routine = allocate_goals(goals, goal_times, task_suggestions, free_time, initial_routine.copy())

    return updated_routine

from datetime import datetime

# Function to convert time string to datetime object for sorting
def time_to_datetime(time_str):
    return datetime.strptime(time_str, '%H:%M')

# Function to ensure time is formatted as HH:MM with two digits
def format_time(time_str):
    return datetime.strptime(time_str, '%H:%M').strftime('%H:%M')

# Function to convert routine dictionary to sorted and formatted time
def sort_routine_by_time(routine_dict):
    # Sort the routine based on the start time
    sorted_routine = dict(sorted(routine_dict.items(), key=lambda item: time_to_datetime(item[1][0])))

    # Add 'wakeup' and 'sleep' at the start and end, respectively
    sorted_routine = {
        'wakeup': ['00:00', '06:00'],  # Wakeup at 6:00 AM
        **sorted_routine,  # Add the rest of the sorted routine
        'sleep': ['22:00', '23:59']  # Sleep at 10:00 PM to 11:59 PM
    }

    # Format the times to always be in HH:MM format
    for task, times in sorted_routine.items():
        sorted_routine[task] = [format_time(times[0]), format_time(times[1])]

    return sorted_routine

routine_dict = {
    'Exercise': '6:00 to 7:00',
    'Breakfast': '7:30 to 8:00',
    'travelto': '8:00 to 8:30',
    'Lectures': '9:00 to 15:00',
    'travelback': '15:30 to 17:00',
    'Study': '18:30 to 19:00',
    'Call Friends': '19:30 to 20:00',
    'mobileuse' : '20:00 to 21:00',
}

wakeup_time = '06:00'
bedtime = '22:00'
goals = ['read many books', 'learn python', 'cooking']

routine_dict = {
    'Yoga Session': '6:00 to 7:00',
    'Healthy Smoothie': '7:00 to 7:30',
    'Team Meeting': '8:30 to 9:00',
    'Project Work': '9:00 to 12:00',
    'Lunch Break': '12:00 to 12:30',
    'Client Calls': '12:30 to 14:00',
    'Write Articles': '14:00 to 16:00',
    'Evening Walk': '16:30 to 17:00',

    'Watch Educational Videos': '18:00 to 19:00',
    'Leisure Reading': '20:30 to 21:30',
}

wakeup_time = '06:00'
bedtime = '22:00'
goals = ['improve fitness', 'enhance writing skills', 'learn about investments']

routine_dict = {

    'Morning Exercise': '6:30 to 7:00',
    'Shower & Get Ready': '7:00 to 7:30',
    'Breakfast': '7:30 to 8:00',
    'Commute to School': '8:00 to 8:30',
    'Classes': '8:30 to 12:30',
    'Lunch Break': '12:30 to 13:00',
    'Study Session 1': '13:00 to 15:00',
    'Group Project Meeting': '15:00 to 16:00',
    'Study Session 2': '16:00 to 18:00',
    'Dinner with Friends': '18:30 to 19:30',

    'Leisure/Relaxation': '20:30 to 21:30',

}

wakeup_time = '06:00'
bedtime = '22:00'
goals = ['learn python', 'music', 'learn to build web']

def generate_routine(wakeup_time ,bedtime,routine_dict,goals):
  sugg_new_regular_routine = predict_best_time(routine_dict, wakeup_time, bedtime, goals)
  print(sugg_new_regular_routine)
  _to_routine_dict=convert_routine_dict(routine_dict)
  free_time=find_free_time(_to_routine_dict, wakeup_time, bedtime)

  unsort_routine = update_routine(sugg_new_regular_routine, goals,_to_routine_dict , free_time)
  updated_routine = sort_routine_by_time(unsort_routine)
  return updated_routine,free_time
new_routine_is, free_time =generate_routine(wakeup_time ,bedtime,routine_dict,goals)

print(new_routine_is)

{ 'wakeup' :['00.06','06.00'] ,
  'Exercise': ['6:00', '7:00'],
 'read many books': ['07:00', '07:30'],
 'Breakfast': ['7:30', '8:00'],
 'travelto': ['8:00', '8:30'],
 'learn python': ['08:30', '09:00'],
 'Lectures': ['9:00', '15:00'],
 'cooking': ['15:00', '15:30']
 'travelback': ['15:30', '17:00'],
 'Study': ['18:30', '19:00'],
 'Call Friends': ['19:30', '20:00'],
 'mobileuse': ['20:00', '21:00'],
 'sleep' :['22.00','23.59']


 }